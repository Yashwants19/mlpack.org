<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>mlpack: mlpack::kmeans::KMeans&lt; MetricType, InitialPartitionPolicy, EmptyClusterPolicy &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacemlpack.html">mlpack</a>      </li>
      <li><a class="el" href="namespacemlpack_1_1kmeans.html">kmeans</a>      </li>
      <li><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html">mlpack::kmeans::KMeans&lt; MetricType, InitialPartitionPolicy, EmptyClusterPolicy &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<h1>mlpack::kmeans::KMeans&lt; MetricType, InitialPartitionPolicy, EmptyClusterPolicy &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="mlpack::kmeans::KMeans" -->
<p>This class implements K-Means clustering.  
<a href="#_details">More...</a></p>

<p><a href="classmlpack_1_1kmeans_1_1KMeans-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#ae43b64ea9ef61b7a12f748c29999cf64">KMeans</a> (const size_t <a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#abc6a0b9b6ea97faf64842ff7d7f4d7d7">maxIterations</a>=1000, const double <a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#a9059afc2188f2f4c7e4f19037fd50e64">overclusteringFactor</a>=1.0, const MetricType <a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#aee1e16cd42a4f0e929de4425eae2608c">metric</a>=MetricType(), const InitialPartitionPolicy <a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#abd03566ab1e18f5b80ae2949549d49c3">partitioner</a>=InitialPartitionPolicy(), const EmptyClusterPolicy <a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#a1d8767b1f129f4eb1cdbb3fead95c02d">emptyClusterAction</a>=EmptyClusterPolicy())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a K-Means object and (optionally) set the parameters which K-Means will be run with.  <a href="#ae43b64ea9ef61b7a12f748c29999cf64"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#a9872e9069ca42c72f6a73b422e9fcc25">Cluster</a> (const MatType &amp;data, const size_t clusters, arma::Col&lt; size_t &gt; &amp;assignments, const bool initialGuess=false) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform k-means clustering on the data, returning a list of cluster assignments.  <a href="#a9872e9069ca42c72f6a73b422e9fcc25"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#a1ef502fb6144ca14db8559ac3d539997">Cluster</a> (const MatType &amp;data, const size_t clusters, arma::Col&lt; size_t &gt; &amp;assignments, MatType &amp;centroids, const bool initialAssignmentGuess=false, const bool initialCentroidGuess=false) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform k-means clustering on the data, returning a list of cluster assignments and also the centroids of each cluster.  <a href="#a1ef502fb6144ca14db8559ac3d539997"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EmptyClusterPolicy &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#aa7e22ac78a9d91ce58a27ee31d9f6e18">EmptyClusterAction</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modify the empty cluster policy.  <a href="#aa7e22ac78a9d91ce58a27ee31d9f6e18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const EmptyClusterPolicy &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#a957ad8fac8fb50d4f803466827aa7306">EmptyClusterAction</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the empty cluster policy.  <a href="#a957ad8fac8fb50d4f803466827aa7306"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#adef43052b1869c74e3dd81a89c97dac2">MaxIterations</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the maximum number of iterations.  <a href="#adef43052b1869c74e3dd81a89c97dac2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#a7c4f491968923b67399399dcbf58b07b">MaxIterations</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the maximum number of iterations.  <a href="#a7c4f491968923b67399399dcbf58b07b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const MetricType &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#a0709c2b85571d04003fd66ab2291876c">Metric</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the distance metric.  <a href="#a0709c2b85571d04003fd66ab2291876c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MetricType &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#ab338813a9416c5485e790657b66c9ab4">Metric</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modify the distance metric.  <a href="#ab338813a9416c5485e790657b66c9ab4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#af8b71486315acccc41770bab869878cb">OverclusteringFactor</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the overclustering factor.  <a href="#af8b71486315acccc41770bab869878cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#ad87c25c4fb5f98d118d62d553b6359c4">OverclusteringFactor</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the overclustering factor. Must be greater than 1.  <a href="#ad87c25c4fb5f98d118d62d553b6359c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const InitialPartitionPolicy &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#a6ed52152da8d5f1d04e9f4afdb27f601">Partitioner</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the initial partitioning policy.  <a href="#a6ed52152da8d5f1d04e9f4afdb27f601"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">InitialPartitionPolicy &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#ae6729b846705c69f6323df6cbff64d2b">Partitioner</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modify the initial partitioning policy.  <a href="#ae6729b846705c69f6323df6cbff64d2b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#a25841daf125817f4b786b596d47d03a7">ToString</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EmptyClusterPolicy&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#a1d8767b1f129f4eb1cdbb3fead95c02d">emptyClusterAction</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Instantiated empty cluster policy.  <a href="#a1d8767b1f129f4eb1cdbb3fead95c02d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#abc6a0b9b6ea97faf64842ff7d7f4d7d7">maxIterations</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum number of iterations before giving up.  <a href="#abc6a0b9b6ea97faf64842ff7d7f4d7d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MetricType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#aee1e16cd42a4f0e929de4425eae2608c">metric</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Instantiated distance metric.  <a href="#aee1e16cd42a4f0e929de4425eae2608c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#a9059afc2188f2f4c7e4f19037fd50e64">overclusteringFactor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factor controlling how many clusters are actually found.  <a href="#a9059afc2188f2f4c7e4f19037fd50e64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">InitialPartitionPolicy&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#abd03566ab1e18f5b80ae2949549d49c3">partitioner</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Instantiated initial partitioning policy.  <a href="#abd03566ab1e18f5b80ae2949549d49c3"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename MetricType = metric::SquaredEuclideanDistance, typename InitialPartitionPolicy = RandomPartition, typename EmptyClusterPolicy = MaxVarianceNewCluster&gt;<br/>
 class mlpack::kmeans::KMeans&lt; MetricType, InitialPartitionPolicy, EmptyClusterPolicy &gt;</h3>

<p>This class implements K-Means clustering. </p>
<p>This implementation supports overclustering, which means that more clusters than are requested will be found; then, those clusters will be merged together to produce the desired number of clusters.</p>
<p>Two template parameters can (optionally) be supplied: the policy for how to find the initial partition of the data, and the actions to be taken when an empty cluster is encountered, as well as the distance metric to be used.</p>
<p>A simple example of how to run K-Means clustering is shown below.</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">extern</span> arma::mat data; <span class="comment">// Dataset we want to run K-Means on.</span>
 arma::Col&lt;size_t&gt; assignments; <span class="comment">// Cluster assignments.</span>

 KMeans&lt;&gt; k; <span class="comment">// Default options.</span>
 k.Cluster(data, 3, assignments); <span class="comment">// 3 clusters.</span>

 <span class="comment">// Cluster using the Manhattan distance, 100 iterations maximum, and an</span>
 <span class="comment">// overclustering factor of 4.0.</span>
 KMeans&lt;metric::ManhattanDistance&gt; k(100, 4.0);
 k.Cluster(data, 6, assignments); <span class="comment">// 6 clusters.</span>
</pre></div><dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>MetricType</em>&nbsp;</td><td>The distance metric to use for this <a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html" title="This class implements K-Means clustering.">KMeans</a>; see <a class="el" href="classmlpack_1_1metric_1_1LMetric.html" title="The L_p metric for arbitrary integer p, with an option to take the root.">metric::LMetric</a> for an example. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InitialPartitionPolicy</em>&nbsp;</td><td>Initial partitioning policy; must implement a default constructor and 'void Cluster(const arma::mat&amp;, const size_t, arma::Col&lt;size_t&gt;&amp;)'. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EmptyClusterPolicy</em>&nbsp;</td><td>Policy for what to do on an empty cluster; must implement a default constructor and 'void EmptyCluster(const arma::mat&amp;, arma::Col&lt;size_t&amp;)'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classmlpack_1_1kmeans_1_1RandomPartition.html" title="A very simple partitioner which partitions the data randomly into the number of desired clusters...">RandomPartition</a>, <a class="el" href="classmlpack_1_1kmeans_1_1RefinedStart.html" title="A refined approach for choosing initial points for k-means clustering.">RefinedStart</a>, <a class="el" href="classmlpack_1_1kmeans_1_1AllowEmptyClusters.html" title="Policy which allows K-Means to create empty clusters without any error being reported.">AllowEmptyClusters</a>, <a class="el" href="classmlpack_1_1kmeans_1_1MaxVarianceNewCluster.html" title="When an empty cluster is detected, this class takes the point furthest from the centroid of the clust...">MaxVarianceNewCluster</a> </dd></dl>

<p>Definition at line <a class="el" href="kmeans_8hpp_source.html#l00063">63</a> of file <a class="el" href="kmeans_8hpp_source.html">kmeans.hpp</a>.</p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae43b64ea9ef61b7a12f748c29999cf64"></a><!-- doxytag: member="mlpack::kmeans::KMeans::KMeans" ref="ae43b64ea9ef61b7a12f748c29999cf64" args="(const size_t maxIterations=1000, const double overclusteringFactor=1.0, const MetricType metric=MetricType(), const InitialPartitionPolicy partitioner=InitialPartitionPolicy(), const EmptyClusterPolicy emptyClusterAction=EmptyClusterPolicy())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::SquaredEuclideanDistance, typename InitialPartitionPolicy  = RandomPartition, typename EmptyClusterPolicy  = MaxVarianceNewCluster&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html">mlpack::kmeans::KMeans</a>&lt; MetricType, InitialPartitionPolicy, EmptyClusterPolicy &gt;::<a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html">KMeans</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&nbsp;</td>
          <td class="paramname"> <em>maxIterations</em> = <code>1000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>overclusteringFactor</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MetricType&nbsp;</td>
          <td class="paramname"> <em>metric</em> = <code>MetricType()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InitialPartitionPolicy&nbsp;</td>
          <td class="paramname"> <em>partitioner</em> = <code>InitialPartitionPolicy()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EmptyClusterPolicy&nbsp;</td>
          <td class="paramname"> <em>emptyClusterAction</em> = <code>EmptyClusterPolicy()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a K-Means object and (optionally) set the parameters which K-Means will be run with. </p>
<p>This implementation allows a few strategies to improve the performance of K-Means, including "overclustering" and disallowing empty clusters.</p>
<p>The overclustering factor controls how many clusters are actually found; for instance, with an overclustering factor of 4, if K-Means is run to find 3 clusters, it will actually find 12, then merge the nearest clusters until only 3 are left.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>maxIterations</em>&nbsp;</td><td>Maximum number of iterations allowed before giving up (0 is valid, but the algorithm may never terminate). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>overclusteringFactor</em>&nbsp;</td><td>Factor controlling how many extra clusters are found and then merged to get the desired number of clusters. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>metric</em>&nbsp;</td><td>Optional MetricType object; for when the metric has state it needs to store. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>partitioner</em>&nbsp;</td><td>Optional InitialPartitionPolicy object; for when a specially initialized partitioning policy is required. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>emptyClusterAction</em>&nbsp;</td><td>Optional EmptyClusterPolicy object; for when a specially initialized empty cluster policy is required. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a9872e9069ca42c72f6a73b422e9fcc25"></a><!-- doxytag: member="mlpack::kmeans::KMeans::Cluster" ref="a9872e9069ca42c72f6a73b422e9fcc25" args="(const MatType &amp;data, const size_t clusters, arma::Col&lt; size_t &gt; &amp;assignments, const bool initialGuess=false) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::SquaredEuclideanDistance, typename InitialPartitionPolicy  = RandomPartition, typename EmptyClusterPolicy  = MaxVarianceNewCluster&gt; </div>
<div class="memtemplate">
template&lt;typename MatType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html">mlpack::kmeans::KMeans</a>&lt; MetricType, InitialPartitionPolicy, EmptyClusterPolicy &gt;::Cluster </td>
          <td>(</td>
          <td class="paramtype">const MatType &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&nbsp;</td>
          <td class="paramname"> <em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Col&lt; size_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>assignments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initialGuess</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform k-means clustering on the data, returning a list of cluster assignments. </p>
<p>Optionally, the vector of assignments can be set to an initial guess of the cluster assignments; to do this, set initialGuess to true.</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>MatType</em>&nbsp;</td><td>Type of matrix (arma::mat or arma::sp_mat). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Dataset to cluster. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clusters</em>&nbsp;</td><td>Number of clusters to compute. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>assignments</em>&nbsp;</td><td>Vector to store cluster assignments in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>initialGuess</em>&nbsp;</td><td>If true, then it is assumed that assignments has a list of initial cluster assignments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ef502fb6144ca14db8559ac3d539997"></a><!-- doxytag: member="mlpack::kmeans::KMeans::Cluster" ref="a1ef502fb6144ca14db8559ac3d539997" args="(const MatType &amp;data, const size_t clusters, arma::Col&lt; size_t &gt; &amp;assignments, MatType &amp;centroids, const bool initialAssignmentGuess=false, const bool initialCentroidGuess=false) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::SquaredEuclideanDistance, typename InitialPartitionPolicy  = RandomPartition, typename EmptyClusterPolicy  = MaxVarianceNewCluster&gt; </div>
<div class="memtemplate">
template&lt;typename MatType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html">mlpack::kmeans::KMeans</a>&lt; MetricType, InitialPartitionPolicy, EmptyClusterPolicy &gt;::Cluster </td>
          <td>(</td>
          <td class="paramtype">const MatType &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&nbsp;</td>
          <td class="paramname"> <em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Col&lt; size_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>assignments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatType &amp;&nbsp;</td>
          <td class="paramname"> <em>centroids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initialAssignmentGuess</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initialCentroidGuess</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform k-means clustering on the data, returning a list of cluster assignments and also the centroids of each cluster. </p>
<p>Optionally, the vector of assignments can be set to an initial guess of the cluster assignments; to do this, set initialAssignmentGuess to true. Another way to set initial cluster guesses is to fill the centroids matrix with the centroid guesses, and then set initialCentroidGuess to true. initialAssignmentGuess supersedes initialCentroidGuess, so if both are set to true, the assignments vector is used.</p>
<p>Note that if the overclustering factor is greater than 1, the centroids matrix will be resized in the method. Regardless of the overclustering factor, the centroid guess matrix (if initialCentroidGuess is set to true) should have the same number of rows as the data matrix, and number of columns equal to 'clusters'.</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>MatType</em>&nbsp;</td><td>Type of matrix (arma::mat or arma::sp_mat). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Dataset to cluster. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clusters</em>&nbsp;</td><td>Number of clusters to compute. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>assignments</em>&nbsp;</td><td>Vector to store cluster assignments in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>centroids</em>&nbsp;</td><td>Matrix in which centroids are stored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>initialAssignmentGuess</em>&nbsp;</td><td>If true, then it is assumed that assignments has a list of initial cluster assignments. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>initialCentroidGuess</em>&nbsp;</td><td>If true, then it is assumed that centroids contains the initial centroids of each cluster. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a957ad8fac8fb50d4f803466827aa7306"></a><!-- doxytag: member="mlpack::kmeans::KMeans::EmptyClusterAction" ref="a957ad8fac8fb50d4f803466827aa7306" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::SquaredEuclideanDistance, typename InitialPartitionPolicy  = RandomPartition, typename EmptyClusterPolicy  = MaxVarianceNewCluster&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const EmptyClusterPolicy&amp; <a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html">mlpack::kmeans::KMeans</a>&lt; MetricType, InitialPartitionPolicy, EmptyClusterPolicy &gt;::EmptyClusterAction </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the empty cluster policy. </p>

<p>Definition at line <a class="el" href="kmeans_8hpp_source.html#l00127">127</a> of file <a class="el" href="kmeans_8hpp_source.html">kmeans.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa7e22ac78a9d91ce58a27ee31d9f6e18"></a><!-- doxytag: member="mlpack::kmeans::KMeans::EmptyClusterAction" ref="aa7e22ac78a9d91ce58a27ee31d9f6e18" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::SquaredEuclideanDistance, typename InitialPartitionPolicy  = RandomPartition, typename EmptyClusterPolicy  = MaxVarianceNewCluster&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EmptyClusterPolicy&amp; <a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html">mlpack::kmeans::KMeans</a>&lt; MetricType, InitialPartitionPolicy, EmptyClusterPolicy &gt;::EmptyClusterAction </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modify the empty cluster policy. </p>

<p>Definition at line <a class="el" href="kmeans_8hpp_source.html#l00130">130</a> of file <a class="el" href="kmeans_8hpp_source.html">kmeans.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adef43052b1869c74e3dd81a89c97dac2"></a><!-- doxytag: member="mlpack::kmeans::KMeans::MaxIterations" ref="adef43052b1869c74e3dd81a89c97dac2" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::SquaredEuclideanDistance, typename InitialPartitionPolicy  = RandomPartition, typename EmptyClusterPolicy  = MaxVarianceNewCluster&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html">mlpack::kmeans::KMeans</a>&lt; MetricType, InitialPartitionPolicy, EmptyClusterPolicy &gt;::MaxIterations </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the maximum number of iterations. </p>

<p>Definition at line <a class="el" href="kmeans_8hpp_source.html#l00112">112</a> of file <a class="el" href="kmeans_8hpp_source.html">kmeans.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7c4f491968923b67399399dcbf58b07b"></a><!-- doxytag: member="mlpack::kmeans::KMeans::MaxIterations" ref="a7c4f491968923b67399399dcbf58b07b" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::SquaredEuclideanDistance, typename InitialPartitionPolicy  = RandomPartition, typename EmptyClusterPolicy  = MaxVarianceNewCluster&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t&amp; <a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html">mlpack::kmeans::KMeans</a>&lt; MetricType, InitialPartitionPolicy, EmptyClusterPolicy &gt;::MaxIterations </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the maximum number of iterations. </p>

<p>Definition at line <a class="el" href="kmeans_8hpp_source.html#l00114">114</a> of file <a class="el" href="kmeans_8hpp_source.html">kmeans.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab338813a9416c5485e790657b66c9ab4"></a><!-- doxytag: member="mlpack::kmeans::KMeans::Metric" ref="ab338813a9416c5485e790657b66c9ab4" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::SquaredEuclideanDistance, typename InitialPartitionPolicy  = RandomPartition, typename EmptyClusterPolicy  = MaxVarianceNewCluster&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MetricType&amp; <a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html">mlpack::kmeans::KMeans</a>&lt; MetricType, InitialPartitionPolicy, EmptyClusterPolicy &gt;::Metric </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modify the distance metric. </p>

<p>Definition at line <a class="el" href="kmeans_8hpp_source.html#l00119">119</a> of file <a class="el" href="kmeans_8hpp_source.html">kmeans.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0709c2b85571d04003fd66ab2291876c"></a><!-- doxytag: member="mlpack::kmeans::KMeans::Metric" ref="a0709c2b85571d04003fd66ab2291876c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::SquaredEuclideanDistance, typename InitialPartitionPolicy  = RandomPartition, typename EmptyClusterPolicy  = MaxVarianceNewCluster&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const MetricType&amp; <a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html">mlpack::kmeans::KMeans</a>&lt; MetricType, InitialPartitionPolicy, EmptyClusterPolicy &gt;::Metric </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the distance metric. </p>

<p>Definition at line <a class="el" href="kmeans_8hpp_source.html#l00117">117</a> of file <a class="el" href="kmeans_8hpp_source.html">kmeans.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad87c25c4fb5f98d118d62d553b6359c4"></a><!-- doxytag: member="mlpack::kmeans::KMeans::OverclusteringFactor" ref="ad87c25c4fb5f98d118d62d553b6359c4" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::SquaredEuclideanDistance, typename InitialPartitionPolicy  = RandomPartition, typename EmptyClusterPolicy  = MaxVarianceNewCluster&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double&amp; <a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html">mlpack::kmeans::KMeans</a>&lt; MetricType, InitialPartitionPolicy, EmptyClusterPolicy &gt;::OverclusteringFactor </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the overclustering factor. Must be greater than 1. </p>

<p>Definition at line <a class="el" href="kmeans_8hpp_source.html#l00109">109</a> of file <a class="el" href="kmeans_8hpp_source.html">kmeans.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af8b71486315acccc41770bab869878cb"></a><!-- doxytag: member="mlpack::kmeans::KMeans::OverclusteringFactor" ref="af8b71486315acccc41770bab869878cb" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::SquaredEuclideanDistance, typename InitialPartitionPolicy  = RandomPartition, typename EmptyClusterPolicy  = MaxVarianceNewCluster&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html">mlpack::kmeans::KMeans</a>&lt; MetricType, InitialPartitionPolicy, EmptyClusterPolicy &gt;::OverclusteringFactor </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the overclustering factor. </p>

<p>Definition at line <a class="el" href="kmeans_8hpp_source.html#l00107">107</a> of file <a class="el" href="kmeans_8hpp_source.html">kmeans.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae6729b846705c69f6323df6cbff64d2b"></a><!-- doxytag: member="mlpack::kmeans::KMeans::Partitioner" ref="ae6729b846705c69f6323df6cbff64d2b" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::SquaredEuclideanDistance, typename InitialPartitionPolicy  = RandomPartition, typename EmptyClusterPolicy  = MaxVarianceNewCluster&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">InitialPartitionPolicy&amp; <a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html">mlpack::kmeans::KMeans</a>&lt; MetricType, InitialPartitionPolicy, EmptyClusterPolicy &gt;::Partitioner </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modify the initial partitioning policy. </p>

<p>Definition at line <a class="el" href="kmeans_8hpp_source.html#l00124">124</a> of file <a class="el" href="kmeans_8hpp_source.html">kmeans.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6ed52152da8d5f1d04e9f4afdb27f601"></a><!-- doxytag: member="mlpack::kmeans::KMeans::Partitioner" ref="a6ed52152da8d5f1d04e9f4afdb27f601" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::SquaredEuclideanDistance, typename InitialPartitionPolicy  = RandomPartition, typename EmptyClusterPolicy  = MaxVarianceNewCluster&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const InitialPartitionPolicy&amp; <a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html">mlpack::kmeans::KMeans</a>&lt; MetricType, InitialPartitionPolicy, EmptyClusterPolicy &gt;::Partitioner </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the initial partitioning policy. </p>

<p>Definition at line <a class="el" href="kmeans_8hpp_source.html#l00122">122</a> of file <a class="el" href="kmeans_8hpp_source.html">kmeans.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a25841daf125817f4b786b596d47d03a7"></a><!-- doxytag: member="mlpack::kmeans::KMeans::ToString" ref="a25841daf125817f4b786b596d47d03a7" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::SquaredEuclideanDistance, typename InitialPartitionPolicy  = RandomPartition, typename EmptyClusterPolicy  = MaxVarianceNewCluster&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html">mlpack::kmeans::KMeans</a>&lt; MetricType, InitialPartitionPolicy, EmptyClusterPolicy &gt;::ToString </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a1d8767b1f129f4eb1cdbb3fead95c02d"></a><!-- doxytag: member="mlpack::kmeans::KMeans::emptyClusterAction" ref="a1d8767b1f129f4eb1cdbb3fead95c02d" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::SquaredEuclideanDistance, typename InitialPartitionPolicy  = RandomPartition, typename EmptyClusterPolicy  = MaxVarianceNewCluster&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EmptyClusterPolicy <a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html">mlpack::kmeans::KMeans</a>&lt; MetricType, InitialPartitionPolicy, EmptyClusterPolicy &gt;::<a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#a1d8767b1f129f4eb1cdbb3fead95c02d">emptyClusterAction</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Instantiated empty cluster policy. </p>

<p>Definition at line <a class="el" href="kmeans_8hpp_source.html#l00145">145</a> of file <a class="el" href="kmeans_8hpp_source.html">kmeans.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abc6a0b9b6ea97faf64842ff7d7f4d7d7"></a><!-- doxytag: member="mlpack::kmeans::KMeans::maxIterations" ref="abc6a0b9b6ea97faf64842ff7d7f4d7d7" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::SquaredEuclideanDistance, typename InitialPartitionPolicy  = RandomPartition, typename EmptyClusterPolicy  = MaxVarianceNewCluster&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html">mlpack::kmeans::KMeans</a>&lt; MetricType, InitialPartitionPolicy, EmptyClusterPolicy &gt;::<a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#abc6a0b9b6ea97faf64842ff7d7f4d7d7">maxIterations</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Maximum number of iterations before giving up. </p>

<p>Definition at line <a class="el" href="kmeans_8hpp_source.html#l00139">139</a> of file <a class="el" href="kmeans_8hpp_source.html">kmeans.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aee1e16cd42a4f0e929de4425eae2608c"></a><!-- doxytag: member="mlpack::kmeans::KMeans::metric" ref="aee1e16cd42a4f0e929de4425eae2608c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::SquaredEuclideanDistance, typename InitialPartitionPolicy  = RandomPartition, typename EmptyClusterPolicy  = MaxVarianceNewCluster&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MetricType <a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html">mlpack::kmeans::KMeans</a>&lt; MetricType, InitialPartitionPolicy, EmptyClusterPolicy &gt;::<a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#aee1e16cd42a4f0e929de4425eae2608c">metric</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Instantiated distance metric. </p>

<p>Definition at line <a class="el" href="kmeans_8hpp_source.html#l00141">141</a> of file <a class="el" href="kmeans_8hpp_source.html">kmeans.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9059afc2188f2f4c7e4f19037fd50e64"></a><!-- doxytag: member="mlpack::kmeans::KMeans::overclusteringFactor" ref="a9059afc2188f2f4c7e4f19037fd50e64" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::SquaredEuclideanDistance, typename InitialPartitionPolicy  = RandomPartition, typename EmptyClusterPolicy  = MaxVarianceNewCluster&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html">mlpack::kmeans::KMeans</a>&lt; MetricType, InitialPartitionPolicy, EmptyClusterPolicy &gt;::<a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#a9059afc2188f2f4c7e4f19037fd50e64">overclusteringFactor</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Factor controlling how many clusters are actually found. </p>

<p>Definition at line <a class="el" href="kmeans_8hpp_source.html#l00137">137</a> of file <a class="el" href="kmeans_8hpp_source.html">kmeans.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abd03566ab1e18f5b80ae2949549d49c3"></a><!-- doxytag: member="mlpack::kmeans::KMeans::partitioner" ref="abd03566ab1e18f5b80ae2949549d49c3" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetricType  = metric::SquaredEuclideanDistance, typename InitialPartitionPolicy  = RandomPartition, typename EmptyClusterPolicy  = MaxVarianceNewCluster&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">InitialPartitionPolicy <a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html">mlpack::kmeans::KMeans</a>&lt; MetricType, InitialPartitionPolicy, EmptyClusterPolicy &gt;::<a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#abd03566ab1e18f5b80ae2949549d49c3">partitioner</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Instantiated initial partitioning policy. </p>

<p>Definition at line <a class="el" href="kmeans_8hpp_source.html#l00143">143</a> of file <a class="el" href="kmeans_8hpp_source.html">kmeans.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/mlpack/methods/kmeans/<a class="el" href="kmeans_8hpp_source.html">kmeans.hpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Jan 7 2015 13:07:10 for mlpack by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
