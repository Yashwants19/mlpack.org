<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>mlpack: NeighborSearch tutorial (k-nearest-neighbors)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>NeighborSearch tutorial (k-nearest-neighbors) </h1>  </div>
</div>
<div class="contents">
<h2><a class="anchor" id="intro_nstut"></a>
Introduction</h2>
<p>Nearest-neighbors search is a common machine learning task. In this setting, we have a <b>query</b> and a <b>reference</b> dataset. For each point in the <b>query</b> dataset, we wish to know the <img class="formulaInl" alt="$k$" src="form_117.png"/> points in the <b>reference</b> dataset which are closest to the given query point.</p>
<p>Alternately, if the query and reference datasets are the same, the problem can be stated more simply: for each point in the dataset, we wish to know the <img class="formulaInl" alt="$k$" src="form_117.png"/> nearest points to that point.</p>
<p><b>mlpack</b> provides:</p>
<ul>
<li>a <a class="el" href="nstutorial.html#cli_nstut">simple command-line executable</a> to run nearest-neighbors search (and furthest-neighbors search)</li>
<li>a <a class="el" href="nstutorial.html#allknn_nstut">simple C++ interface</a> to perform nearest-neighbors search (and furthest-neighbors search)</li>
<li>a <a class="el" href="nstutorial.html#neighborsearch_nstut">generic, extensible, and powerful C++ class (NeighborSearch)</a> for complex usage</li>
</ul>
<h2><a class="anchor" id="toc_nstut"></a>
Table of Contents</h2>
<p>A list of all the sections this tutorial contains.</p>
<ul>
<li><a class="el" href="nstutorial.html#intro_nstut">Introduction</a></li>
<li><a class="el" href="nstutorial.html#toc_nstut">Table of Contents</a></li>
<li><a class="el" href="nstutorial.html#cli_nstut">Command-Line 'allknn'</a><ul>
<li><a class="el" href="nstutorial.html#cli_ex1_nstut">One dataset, 5 nearest neighbors</a></li>
<li><a class="el" href="nstutorial.html#cli_ex2_nstut">Query and reference dataset, 10 nearest neighbors</a></li>
<li><a class="el" href="nstutorial.html#cli_ex3_nstut">One dataset, 3 nearest neighbors, leaf size of 15 points</a></li>
</ul>
</li>
<li><a class="el" href="nstutorial.html#allknn_nstut">The 'AllkNN' class</a><ul>
<li><a class="el" href="nstutorial.html#allknn_ex1_nstut">5 nearest neighbors on a single dataset</a></li>
<li><a class="el" href="nstutorial.html#allknn_ex2_nstut">10 nearest neighbors on a query and reference dataset</a></li>
<li><a class="el" href="nstutorial.html#allknn_ex3_nstut">Naive (exhaustive) search for 6 nearest neighbors on one dataset</a></li>
</ul>
</li>
<li><a class="el" href="nstutorial.html#neighborsearch_nstut">The extensible 'NeighborSearch' class</a><ul>
<li><a class="el" href="nstutorial.html#sort_policy_doc_nstut">SortPolicy policy class</a></li>
<li><a class="el" href="nstutorial.html#metric_type_doc_nstut">MetricType policy class</a></li>
<li><a class="el" href="nstutorial.html#tree_type_doc_nstut">TreeType policy class</a></li>
</ul>
</li>
<li><a class="el" href="nstutorial.html#further_doc_nstut">Further documentation</a></li>
</ul>
<h2><a class="anchor" id="cli_nstut"></a>
Command-Line 'allknn'</h2>
<p>The simplest way to perform nearest-neighbors search in <b>mlpack</b> is to use the allknn executable. This program will perform nearest-neighbors search and place the resultant neighbors into one file and the resultant distances into another. The output files are organized such that the first row corresponds to the nearest neighbors of the first query point, with the first column corresponding to the nearest neighbor, and so forth.</p>
<p>Below are several examples of simple usage (and the resultant output). The '-v' option is used so that output is given. Further documentation on each individual option can be found by typing</p>
<div class="fragment"><pre class="fragment">$ allknn --help
</pre></div><h3><a class="anchor" id="cli_ex1_nstut"></a>
One dataset, 5 nearest neighbors</h3>
<div class="fragment"><pre class="fragment">$ allknn -r dataset.csv -n neighbors_out.csv -d distances_out.csv -k 5 -v
[INFO ] Loading <span class="stringliteral">&#39;dataset.csv&#39;</span> as CSV data.
[INFO ] Loaded reference data from <span class="stringliteral">&#39;dataset.csv&#39;</span>.
[INFO ] Building reference tree...
[INFO ] Trees built.
[INFO ] Computing 5 nearest neighbors...
[INFO ] Neighbors computed.
[INFO ] Re-mapping indices...
[INFO ] Saving CSV data to <span class="stringliteral">&#39;distances_out.csv&#39;</span>.
[INFO ] Saving CSV data to <span class="stringliteral">&#39;neighbors_out.csv&#39;</span>.
[INFO ]
[INFO ] Execution parameters:
[INFO ]   distances_file: distances_out.csv
[INFO ]   help: <span class="keyword">false</span>
[INFO ]   info: <span class="stringliteral">&quot;&quot;</span>
[INFO ]   k: 5
[INFO ]   leaf_size: 20
[INFO ]   naive: <span class="keyword">false</span>
[INFO ]   neighbors_file: neighbors_out.csv
[INFO ]   query_file: <span class="stringliteral">&quot;&quot;</span>
[INFO ]   reference_file: dataset.csv
[INFO ]   single_mode: <span class="keyword">false</span>
[INFO ]   verbose: <span class="keyword">true</span>
[INFO ]
[INFO ] Program timers:
[INFO ]   computing_neighbors: 0.152495s
[INFO ]   total_time: 0.201274s
[INFO ]   tree_building: 0.005050s
</pre></div><p>Convenient program timers are given for different parts of the calculation at the bottom of the output, as well as the parameters the simulation was run with. Now, if we look at the output files:</p>
<div class="fragment"><pre class="fragment">$ head neighbors_out.csv
14,5,13,16,27
90,79,80,15,10
39,84,10,123,1
81,43,109,12,37
15,1,79,90,10
0,14,16,13,27
90,79,11,1,15
41,45,12,37,49
11,81,13,6,15
41,7,45,49,47

$ head distances_out.csv
7.09614421e-04,2.05940173e-03,4.05346068e-03,4.66175278e-03,1.09757665e-02
8.92190948e-04,1.69442242e-03,2.82750475e-03,4.06590850e-03,7.54169243e-03
5.91539406e-03,6.83482612e-03,8.02877800e-03,9.04907425e-03,1.61458442e-02
7.15652913e-03,9.18228524e-03,1.00540941e-02,1.07541171e-02,1.28892864e-02
5.37535983e-03,9.05721409e-03,9.89017184e-03,1.01457735e-02,1.14021593e-02
2.05940173e-03,5.14437192e-03,9.97483954e-03,1.02463627e-02,1.44355783e-02
4.27355419e-03,6.36750547e-03,6.72478577e-03,8.77323532e-03,1.04530549e-02
1.99935847e-03,3.88240331e-03,4.19118273e-03,9.30693568e-03,1.21237481e-02
2.15454276e-03,8.18895210e-03,1.18360450e-02,1.25135454e-02,1.27783327e-02
8.43087996e-03,1.22946325e-02,1.60472209e-02,1.88661413e-02,1.89727686e-02
</pre></div><p>So, the nearest neighbor to point 0 is point 14, with a distance of 7.096144e-4. The second nearest neighbor to point 0 is point 5, with a distance of 2.059402e-3. The third nearest neighbor to point 5 is point 16, with a distance of 9.9748395e-3.</p>
<h3><a class="anchor" id="cli_ex2_nstut"></a>
Query and reference dataset, 10 nearest neighbors</h3>
<div class="fragment"><pre class="fragment">$ allknn -q query_dataset.csv -r reference_dataset.csv -n neighbors_out.csv \
&gt; -d distances_out.csv -k 10 -v
[INFO ] Loading <span class="stringliteral">&#39;reference_dataset.csv&#39;</span> as CSV data.
[INFO ] Loaded reference data from <span class="stringliteral">&#39;reference_dataset.csv&#39;</span>.
[INFO ] Building reference tree...
[INFO ] Loading <span class="stringliteral">&#39;query_dataset.csv&#39;</span> as CSV data.
[INFO ] Query data loaded from <span class="stringliteral">&#39;query_dataset.csv&#39;</span>.
[INFO ] Building query tree...
[INFO ] <a class="code" href="TREE__EXPLANATION_8txt.html#acb8010dba0cbb36077c0b765e86d0891">Tree</a> built.
[INFO ] Computing 10 nearest neighbors...
[INFO ] Neighbors computed.
[INFO ] Re-mapping indices...
[INFO ] Saving CSV data to <span class="stringliteral">&#39;distances_out.csv&#39;</span>.
[INFO ] Saving CSV data to <span class="stringliteral">&#39;neighbors_out.csv&#39;</span>.
[INFO ]
[INFO ] Execution parameters:
[INFO ]   distances_file: distances_out.csv
[INFO ]   help: <span class="keyword">false</span>
[INFO ]   info: <span class="stringliteral">&quot;&quot;</span>
[INFO ]   k: 10
[INFO ]   leaf_size: 20
[INFO ]   naive: <span class="keyword">false</span>
[INFO ]   neighbors_file: neighbors_out.csv
[INFO ]   query_file: query_dataset.csv
[INFO ]   reference_file: reference_dataset.csv
[INFO ]   single_mode: <span class="keyword">false</span>
[INFO ]   verbose: <span class="keyword">true</span>
[INFO ]
[INFO ] Program timers:
[INFO ]   computing_neighbors: 0.000081s
[INFO ]   total_time: 0.062828s
[INFO ]   tree_building: 0.004949s
</pre></div><h3><a class="anchor" id="cli_ex3_nstut"></a>
One dataset, 3 nearest neighbors, leaf size of 15 points</h3>
<div class="fragment"><pre class="fragment">$ allknn -r dataset.csv -n neighbors_out.csv -d distances_out.csv -k 3 -l 15 -v
[INFO ] Loading <span class="stringliteral">&#39;dataset.csv&#39;</span> as CSV data.
[INFO ] Loaded reference data from <span class="stringliteral">&#39;dataset.csv&#39;</span>.
[INFO ] Building reference tree...
[INFO ] Trees built.
[INFO ] Computing 3 nearest neighbors...
[INFO ] Neighbors computed.
[INFO ] Re-mapping indices...
[INFO ] Saving CSV data to <span class="stringliteral">&#39;distances_out.csv&#39;</span>.
[INFO ] Saving CSV data to <span class="stringliteral">&#39;neighbors_out.csv&#39;</span>.
[INFO ]
[INFO ] Execution parameters:
[INFO ]   distances_file: distances_out.csv
[INFO ]   help: <span class="keyword">false</span>
[INFO ]   info: <span class="stringliteral">&quot;&quot;</span>
[INFO ]   k: 3
[INFO ]   leaf_size: 15
[INFO ]   naive: <span class="keyword">false</span>
[INFO ]   neighbors_file: neighbors_out.csv
[INFO ]   query_file: <span class="stringliteral">&quot;&quot;</span>
[INFO ]   reference_file: dataset.csv
[INFO ]   single_mode: <span class="keyword">false</span>
[INFO ]   verbose: <span class="keyword">true</span>
[INFO ]
[INFO ] Program timers:
[INFO ]   computing_neighbors: 0.105119s
[INFO ]   total_time: 0.145321s
[INFO ]   tree_building: 0.005690s
</pre></div><p>Further documentation on options should be found by using the --help option.</p>
<h2><a class="anchor" id="allknn_nstut"></a>
The 'AllkNN' class</h2>
<p>The 'AllkNN' class is, specifically, a typedef of the more extensible NeighborSearch class, querying for nearest neighbors using the Euclidean distance.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> NeighborSearch&lt;NearestNeighborSort, metric::EuclideanDistance&gt;
    AllkNN;
</pre></div><p>Using the AllkNN class is particularly simple; first, the object must be constructed and given a dataset. Then, the method is run, and two matrices are returned: one which holds the indices of the nearest neighbors, and one which holds the distances of the nearest neighbors. These are of the same structure as the output --neighbors_file and --distances_file for the CLI interface (see above). A handful of examples of simple usage of the AllkNN class are given below.</p>
<h3><a class="anchor" id="allknn_ex1_nstut"></a>
5 nearest neighbors on a single dataset</h3>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="neighbor__search_8hpp.html">mlpack/methods/neighbor_search/neighbor_search.hpp</a>&gt;</span>

<span class="keyword">using namespace </span>mlpack::neighbor;

<span class="comment">// Our dataset matrix, which is column-major.</span>
<span class="keyword">extern</span> arma::mat data;

AllkNN a(data);

<span class="comment">// The matrices we will store output in.</span>
arma::Mat&lt;size_t&gt; resultingNeighbors;
arma::mat resultingDistances;

a.Search(5, resultingNeighbors, resultingDistances);
</pre></div><p>The output of the search is stored in resultingNeighbors and resultingDistances.</p>
<h3><a class="anchor" id="allknn_ex2_nstut"></a>
10 nearest neighbors on a query and reference dataset</h3>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="neighbor__search_8hpp.html">mlpack/methods/neighbor_search/neighbor_search.hpp</a>&gt;</span>

<span class="keyword">using namespace </span>mlpack::neighbor;

<span class="comment">// Our dataset matrices, which are column-major.</span>
<span class="keyword">extern</span> arma::mat queryData, referenceData;

AllkNN a(referenceData, queryData);

<span class="comment">// The matrices we will store output in.</span>
arma::Mat&lt;size_t&gt; resultingNeighbors;
arma::mat resultingDistances;

a.Search(10, resultingNeighbors, resultingDistances);
</pre></div><h3><a class="anchor" id="allknn_ex3_nstut"></a>
Naive (exhaustive) search for 6 nearest neighbors on one dataset</h3>
<p>This example uses the O(n^2) naive search (not the tree-based search).</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="neighbor__search_8hpp.html">mlpack/methods/neighbor_search/neighbor_search.hpp</a>&gt;</span>

<span class="keyword">using namespace </span>mlpack::neighbor;

<span class="comment">// Our dataset matrix, which is column-major.</span>
<span class="keyword">extern</span> arma::mat dataset;

AllkNN a(dataset, <span class="keyword">true</span>);

<span class="comment">// The matrices we will store output in.</span>
arma::Mat&lt;size_t&gt; resultingNeighbors;
arma::mat resultingDistances;

a.Search(6, resultingNeighbors, resultingDistances);
</pre></div><p>Needless to say, naive search can be very slow...</p>
<h2><a class="anchor" id="neighborsearch_nstut"></a>
The extensible 'NeighborSearch' class</h2>
<p>The NeighborSearch class is very extensible, having the following template arguments:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span>&lt;
  <span class="keyword">typename</span> SortPolicy = NearestNeighborSort,
  <span class="keyword">typename</span> MetricType = <a class="code" href="classmlpack_1_1metric_1_1LMetric.html" title="The L_p metric for arbitrary integer p, with an option to take the root.">mlpack::metric::EuclideanDistance</a>,
  <span class="keyword">typename</span> TreeType = <a class="code" href="classmlpack_1_1tree_1_1BinarySpaceTree.html" title="A binary space partitioning tree, such as a KD-tree or a ball tree.">mlpack::tree::BinarySpaceTree&lt;bound::HRectBound&lt;2&gt;</a>,
                                                    QueryStat&lt;SortPolicy&gt; &gt;
&gt;
<span class="keyword">class </span>NeighborSearch;
</pre></div><p>By choosing different components for each of these template classes, a very arbitrary neighbor searching object can be constructed.</p>
<h3><a class="anchor" id="sort_policy_doc_nstut"></a>
SortPolicy policy class</h3>
<p>The SortPolicy template parameter allows specification of how the NeighborSearch object will decide which points are to be searched for. The <a class="el" href="classmlpack_1_1neighbor_1_1NearestNeighborSort.html" title="This class implements the necessary methods for the SortPolicy template parameter of the NeighborSear...">mlpack::neighbor::NearestNeighborSort</a> class is a well-documented example. A custom SortPolicy class must implement the same methods which NearestNeighborSort does:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keywordtype">size_t</span> SortDistance(<span class="keyword">const</span> arma::vec&amp; list, <span class="keywordtype">double</span> newDistance);

<span class="keyword">static</span> <span class="keywordtype">bool</span> IsBetter(<span class="keyword">const</span> <span class="keywordtype">double</span> value, <span class="keyword">const</span> <span class="keywordtype">double</span> ref);

<span class="keyword">template</span>&lt;<span class="keyword">typename</span> TreeType&gt;
<span class="keyword">static</span> <span class="keywordtype">double</span> BestNodeToNodeDistance(<span class="keyword">const</span> TreeType* queryNode,
                                     <span class="keyword">const</span> TreeType* referenceNode);

<span class="keyword">template</span>&lt;<span class="keyword">typename</span> TreeType&gt;
<span class="keyword">static</span> <span class="keywordtype">double</span> BestPointToNodeDistance(<span class="keyword">const</span> arma::vec&amp; queryPoint,
                                      <span class="keyword">const</span> TreeType* referenceNode);

<span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> WorstDistance();

<span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> BestDistance();
</pre></div><p>The <a class="el" href="classmlpack_1_1neighbor_1_1FurthestNeighborSort.html" title="This class implements the necessary methods for the SortPolicy template parameter of the NeighborSear...">mlpack::neighbor::FurthestNeighborSort</a> class is another implementation, which is used to create the 'AllkFN' typedef class, which finds the furthest neighbors, as opposed to the nearest neighbors.</p>
<h3><a class="anchor" id="metric_type_doc_nstut"></a>
MetricType policy class</h3>
<p>The MetricType policy class allows the neighbor search to take place in any arbitrary metric space. The <a class="el" href="classmlpack_1_1metric_1_1LMetric.html" title="The L_p metric for arbitrary integer p, with an option to take the root.">mlpack::metric::LMetric</a> class is a good example implementation. A MetricType class must provide the following functions:</p>
<div class="fragment"><pre class="fragment"><span class="comment">// Empty constructor is required.</span>
MetricType();

<span class="comment">// Compute the distance between two points.</span>
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> VecType&gt;
<span class="keywordtype">double</span> Evaluate(<span class="keyword">const</span> VecType&amp; a, <span class="keyword">const</span> VecType&amp; b);
</pre></div><p>Internally, the NeighborSearch class keeps an instantiated MetricType class (which can be given in the constructor). This is useful for a metric like the Mahalanobis distance (<a class="el" href="classmlpack_1_1metric_1_1MahalanobisDistance.html" title="The Mahalanobis distance, which is essentially a stretched Euclidean distance.">mlpack::metric::MahalanobisDistance</a>), which must store state (the covariance matrix). Therefore, you can write a non-static MetricType class and use it seamlessly with NeighborSearch.</p>
<h3><a class="anchor" id="tree_type_doc_nstut"></a>
TreeType policy class</h3>
<p>The NeighborSearch class also allows a custom tree to be used. The standard MLPACK tree, <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html" title="A binary space partitioning tree, such as a KD-tree or a ball tree.">mlpack::tree::BinarySpaceTree</a>, is also highly extensible in its own right, and its documentation should be consulted for more information. Currently, the NeighborSearch tree requires a tree which only has left and right children, and no points in nodes (only in leaves), but this support is planned to be extended.</p>
<p>A simple usage of the TreeType policy could be to use a different type of bound with the tree. For instance, you could use a ball bound instead of a rectangular bound:</p>
<div class="fragment"><pre class="fragment"><span class="comment">// Construct a NeighborSearch object with ball bounds.</span>
NeighborSearch&lt;
  NearestNeighborSort,
  metric::EuclideanDistance,
  tree::BinarySpaceTree&lt;bound::BallBound&lt;2&gt;,
                        QueryStat&lt;SortPolicy&gt; &gt;
&gt; neighborSearch(dataset);
</pre></div><p>It is important to note that the NeighborSearch class requires use of the QueryStat tree statistic to function properly. Therefore, if you write a custom tree, be sure it can accept the QueryStat type. See the <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html" title="A binary space partitioning tree, such as a KD-tree or a ball tree.">mlpack::tree::BinarySpaceTree</a> documentation for more information on tree statistics.</p>
<h2><a class="anchor" id="further_doc_nstut"></a>
Further documentation</h2>
<p>For further documentation on the NeighborSearch class, consult the <a class="el" href="classmlpack_1_1neighbor_1_1NeighborSearch.html">complete API documentation</a>. </p>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Jan 7 2015 13:07:09 for mlpack by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
