<html >
<head >

<meta name="keywords" content="mlpack, libmlpack, c++, armadillo, machine learning, data mining, classification, regression, tree-based methods, dual-tree algorithm">
<meta name="description" content="mlpack: a fast, flexible c++ machine learning library">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title >mlpack: a fast, flexible c++ machine learning library</title>
</head><link rel="stylesheet" href="../../../style.css" /></link><link rel="stylesheet" href="../../style-python.css" /></link><link href="http://fonts.googleapis.com/css?family=Maven+Pro:500" rel="stylesheet" type="text/css" /></link>



<body ><br /></br>


<div class="titlebar">
   <a href="http://www.mlpack.org"><img src="../../../mlpack.png"></a>
</div>
<center >
<div class="mlnavbar">
  <div class="navcontainer">
   <div class="mlnavitem" name="mlnavmain"><a href="../../../index.html">main</a></div>
   <div class="mlnavitem" name="mlnavabout"><a href="../../../about.html">about</a></div>
   <div class="mlnavitem" name="mlnavdoc"><a href="../../../docs.html">docs</a></div>
   <div class="mlnavitem" name="mlnavhelp"><a href="../../../help.html">get help</a></div>
   <div class="mlnavitem" name="mlnavbugs"><a href="https://github.com/mlpack/mlpack">github</a></div>
  </div>
</div>
</center>
<div class="separator"></div>
<center >
<div class="mainsection smallertext pythonpage">
<h1><center>mlpack.nmf</center></h1>
<font class="titlecode">nmf(...)</font><br />
<font class="titlebold">Non-negative Matrix Factorization</font>
<p class="importcode">&gt;&gt;&gt; from mlpack import nmf</p><p>This program performs non-negative matrix factorization on the given dataset, storing the resulting decomposed matrices in the specified files.  For an input dataset V, NMF decomposes V into two matrices W and H such that </p>
</p>
<p>V = W * H</p>
</p>
<p>where all elements in W and H are non-negative.  If V is of size (n x m), then W will be of size (n x r) and H will be of size (r x m), where r is the rank of the factorization (specified by the <font class="code">'rank'</font> parameter).</p>
</p>
<p>Optionally, the desired update rules for each NMF iteration can be chosen from the following list:</p>
</p>
<p> - multdist: multiplicative distance-based update rules (Lee and Seung 1999)</p>
<p> - multdiv: multiplicative divergence-based update rules (Lee and Seung 1999)</p>
<p> - als: alternating least squares update rules (Paatero and Tapper 1994)</p>
</p>
<p>The maximum number of iterations is specified with <font class="code">'max_iterations'</font>, and the minimum residue required for algorithm termination is specified with the <font class="code">'min_residue'</font> parameter.</p>
</p>
<p>For example, to run NMF on the input matrix <font class="code">'V'</font> using the <font class="code">'multdist'</font> update rules with a rank-10 decomposition and storing the decomposed matrices into <font class="code">'W'</font> and <font class="code">'H'</font>, the following command could be used: </p>
</p>
<p class="codeblock"><font class="code">&gt;&gt;&gt; nmf(input=V, rank=10, update_rules='multdist')<br />
&gt;&gt;&gt; W = output['w']<br />
&gt;&gt;&gt; H = output['h']</font></p><h2>input options</h2>
<ul>
<li><font class="code">input</font> <font class="codetype">(numpy matrix or arraylike, float dtype)</font>: <font class="required">[required]</font> Input dataset to perform NMF on.</li><li><font class="code">rank</font> <font class="codetype">(int)</font>: <font class="required">[required]</font> Rank of the factorization.  Default value 0.</li><li><font class="code">copy_all_inputs</font> <font class="codetype">(bool)</font>: If specified, all input parameters will be deep copied before the method is run.  This is useful for debugging problems where the input parameters are being modified by the algorithm, but can slow down the code.</li><li><font class="code">initial_h</font> <font class="codetype">(numpy matrix or arraylike, float dtype)</font>: Initial H matrix.</li><li><font class="code">initial_w</font> <font class="codetype">(numpy matrix or arraylike, float dtype)</font>: Initial W matrix.</li><li><font class="code">max_iterations</font> <font class="codetype">(int)</font>: Number of iterations before NMF terminates (0 runs until convergence.  Default value 10000.</li><li><font class="code">min_residue</font> <font class="codetype">(float)</font>: The minimum root mean square residue allowed for each iteration, below which the program terminates.  Default value 1e-05.</li><li><font class="code">seed</font> <font class="codetype">(int)</font>: Random seed.  If 0, 'std::time(NULL)' is used.  Default value 0.</li><li><font class="code">update_rules</font> <font class="codetype">(string)</font>: Update rules for each iteration; ( multdist | multdiv | als ).  Default value multdist.</li><li><font class="code">verbose</font> <font class="codetype">(bool)</font>: Display informational messages and the full list of parameters and timers at the end of execution.</li></ul>
<h2>output options</h2>
<p>The return value from the binding is a dict containing the following elements:</p>
<ul><li><font class="code">h</font> <font class="codetype">(numpy matrix, float dtype)</font>: Matrix to save the calculated H to.</li><li><font class="code">w</font> <font class="codetype">(numpy matrix, float dtype)</font>: Matrix to save the calculated W to.</li><ul>
</ul>
</div>
</body>
</html>
